-- File: AES3_TX.vhd
-- Generated by MyHDL 0.8.1
-- Date: Sun Nov 23 01:08:11 2014


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_081.all;

entity AES3_TX is
    port (
        audio_ch1: in unsigned(23 downto 0);
        cs1: in std_logic;
        valid1: in std_logic;
        user1: in std_logic;
        audio_ch2: in unsigned(23 downto 0);
        cs2: in std_logic;
        valid2: in std_logic;
        user2: in std_logic;
        frame0: in std_logic;
        ce_word: in std_logic;
        ce_bit: in std_logic;
        ce_bp: in std_logic;
        sdata: out std_logic;
        clk: in std_logic;
        rst: in std_logic
    );
end entity AES3_TX;


architecture MyHDL of AES3_TX is


constant PRE_Z_INV: integer := 232;
constant PRE_Y_INV: integer := 216;
constant PRE_X_INV: integer := 184;
constant PRE_Z: integer := 23;
constant PRE_Y: integer := 39;
constant PRE_X: integer := 71;



signal seq: unsigned(36 downto 0);
signal txd: std_logic;
signal set_out_xz: std_logic;
signal b0: std_logic;
signal dout: std_logic;
signal out_y: std_logic;
signal last_state: std_logic;
signal set_out_y: std_logic;
signal state: std_logic;
signal set_out_ch1: std_logic;
signal set_out_ch2: std_logic;
signal frame0_reg: std_logic;
signal inreg1: unsigned(26 downto 0);
signal inreg2: unsigned(26 downto 0);
signal parity2: std_logic;
signal parity1: std_logic;
signal sr: unsigned(27 downto 0);
signal pre_sr: unsigned(7 downto 0);
signal out_xz: std_logic;
signal out_ch2: std_logic;
signal out_ch1: std_logic;
signal b1: std_logic;

begin




AES3_TX_STATE_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            state <= '0';
        elsif bool(ce_bp) then
            state <= ce_bit;
        end if;
    end if;
end process AES3_TX_STATE_LOGIC;


AES3_TX_INPUT_REG: process (clk) is
begin
    if rising_edge(clk) then
        if bool(ce_word) then
            inreg1 <= unsigned'(cs1 & user1 & valid1 & audio_ch1);
            inreg2 <= unsigned'(cs2 & user2 & valid2 & audio_ch2);
            frame0_reg <= frame0;
        end if;
    end if;
end process AES3_TX_INPUT_REG;


AES3_TX_AUDIO_SHIFT_REG: process (clk) is
begin
    if rising_edge(clk) then
        if bool(ce_bit) then
            if bool(seq(1)) then
                sr <= unsigned'(parity1 & inreg1);
            elsif bool(seq(33)) then
                sr <= unsigned'(parity2 & inreg2);
            elsif (bool(out_ch1) or bool(out_ch2)) then
                sr <= unsigned'('0' & sr(28-1 downto 1));
            end if;
        end if;
    end if;
end process AES3_TX_AUDIO_SHIFT_REG;


AES3_TX_PARITY_GEN: process (inreg1, inreg2) is
    variable p2: integer;
    variable p1: integer;
begin
    p1 := to_integer(inreg1(0));
    p2 := to_integer(inreg2(0));
    for i in 0 to (27 - 1)-1 loop
        p1 := p1 xor to_integer(inreg1((i + 1)));
        p2 := p2 xor to_integer(inreg2((i + 1)));
    end loop;
    parity1 <= stdl(p1);
    parity2 <= stdl(p2);
end process AES3_TX_PARITY_GEN;


AES3_TX_SEQUENCER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(ce_bit) then
            seq <= unsigned'(seq(36-1 downto 0) & ce_word);
        end if;
    end if;
end process AES3_TX_SEQUENCER;


AES3_TX_OUTPUT_SETTER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(ce_bit) then
            set_out_xz <= '0';
            set_out_y <= '0';
            set_out_ch1 <= '0';
            set_out_ch2 <= '0';
            if bool(seq(0)) then
                set_out_xz <= '1';
            end if;
            if bool(seq(4)) then
                set_out_ch1 <= '1';
            end if;
            if bool(seq(32)) then
                set_out_y <= '1';
            end if;
            if bool(seq(36)) then
                set_out_ch2 <= '1';
            end if;
        end if;
    end if;
end process AES3_TX_OUTPUT_SETTER;


AES3_TX_OUTPUT_CH1: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            out_ch1 <= '0';
        else
            if bool(ce_bit) then
                if bool(set_out_ch1) then
                    out_ch1 <= '1';
                elsif bool(set_out_y) then
                    out_ch1 <= '0';
                end if;
            end if;
        end if;
    end if;
end process AES3_TX_OUTPUT_CH1;


AES3_TX_OUTPUT_CH2: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            out_ch2 <= '0';
        else
            if bool(ce_bit) then
                if bool(set_out_ch2) then
                    out_ch2 <= '1';
                elsif bool(set_out_xz) then
                    out_ch2 <= '0';
                end if;
            end if;
        end if;
    end if;
end process AES3_TX_OUTPUT_CH2;


AES3_TX_OUTPUT_XZ: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            out_xz <= '0';
        else
            if bool(ce_bit) then
                if bool(set_out_xz) then
                    out_xz <= '1';
                elsif bool(set_out_ch1) then
                    out_xz <= '0';
                end if;
            end if;
        end if;
    end if;
end process AES3_TX_OUTPUT_XZ;


AES3_TX_OUTPUT_Y: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            out_y <= '0';
        else
            if bool(ce_bit) then
                if bool(set_out_y) then
                    out_y <= '1';
                elsif bool(set_out_ch2) then
                    out_y <= '0';
                end if;
            end if;
        end if;
    end if;
end process AES3_TX_OUTPUT_Y;


AES3_TX_PREAMBLE_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if bool(ce_bp) then
            if (bool(seq(1)) and bool(ce_bit)) then
                if bool(frame0_reg) then
                    if bool(b1) then
                        pre_sr <= to_unsigned(PRE_Z_INV, 8);
                    else
                        pre_sr <= to_unsigned(PRE_Z, 8);
                    end if;
                else
                    if bool(b1) then
                        pre_sr <= to_unsigned(PRE_X_INV, 8);
                    else
                        pre_sr <= to_unsigned(PRE_X, 8);
                    end if;
                end if;
            elsif (bool(seq(33)) and bool(ce_bit)) then
                if bool(b1) then
                    pre_sr <= to_unsigned(PRE_Y_INV, 8);
                else
                    pre_sr <= to_unsigned(PRE_Y, 8);
                end if;
            else
                pre_sr <= unsigned'('0' & pre_sr(8-1 downto 1));
            end if;
        end if;
    end if;
end process AES3_TX_PREAMBLE_LOGIC;



dout <= pre_sr(0) when (bool(out_xz) or bool(out_y)) else sr(0);
txd <= b0 when bool(state) else b1;



b0 <= dout when (bool(out_xz) or bool(out_y)) else stdl((not bool(last_state)));



b1 <= dout when (bool(out_xz) or bool(out_y)) else (b0 xor dout);


AES3_TX_LAST_STATE_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if bool(ce_bit) then
            last_state <= b1;
        end if;
    end if;
end process AES3_TX_LAST_STATE_LOGIC;


AES3_TX_SDATA_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if bool(ce_bp) then
            sdata <= txd;
        end if;
    end if;
end process AES3_TX_SDATA_LOGIC;

end architecture MyHDL;
