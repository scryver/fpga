-- File: AES3_RX_DEMUXED.vhd
-- Generated by MyHDL 0.8.1
-- Date: Sun Nov 23 01:08:11 2014


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_081.all;

entity AES3_RX_DEMUXED is
    port (
        din: in std_logic;
        audio1: out std_logic_vector(23 downto 0);
        valid1: out std_logic;
        user1: out std_logic;
        cs1: out std_logic;
        out_en: out std_logic;
        audio2: out std_logic_vector(23 downto 0);
        valid2: out std_logic;
        user2: out std_logic;
        cs2: out std_logic;
        parity_error: out std_logic;
        frames: out std_logic_vector(7 downto 0);
        frame0: out std_logic;
        locked: out std_logic;
        clk: in std_logic;
        rst: in std_logic
    );
end entity AES3_RX_DEMUXED;


architecture ScryverDesign of AES3_RX_DEMUXED is


constant MIN_VAL_MAX: integer := 2**10-1;
constant update_tc: integer := 2**10-1;
constant MIN_VAL_WIDTH: integer := 10;
constant LCK_MAX: integer := 2**13-1;



signal user_data: std_logic;
signal framer_valid: std_logic;
signal z_preamble: std_logic;
signal recdata_valid: std_logic;
signal frames_int: unsigned(7 downto 0);
signal valid: std_logic;
signal recdata: std_logic;
signal cs: std_logic;
signal valid1_hold: std_logic;
signal cs1_hold: std_logic;
signal parity_error_int: std_logic;
signal locked_timeout: unsigned(12 downto 0);
signal channel2: std_logic;
signal y_preamble: std_logic;
signal user1_hold: std_logic;
signal x_preamble: std_logic;
signal audio1_hold: unsigned(23 downto 0);
signal channel1: std_logic;
signal framer_out: unsigned(7 downto 0);
signal audio: unsigned(23 downto 0);
signal aes_rx_formatter_ce: std_logic;
signal aes_rx_formatter_in_reg: unsigned(27 downto 0);
signal aes_rx_formatter_sub: std_logic;
signal aes_rx_formatter_byte_count: unsigned(3 downto 0);
signal aes_rx_formatter_frames_int: unsigned(7 downto 0);
signal aes_rx_formatter_preamble_in: std_logic;
signal aes_rx_formatter_ld_out: std_logic;
signal aes_framer_int_xyz: unsigned(2 downto 0);
signal aes_framer_in_sr: unsigned(8 downto 0);
signal aes_framer_deser: unsigned(7 downto 0);
signal aes_framer_x_detect: std_logic;
signal aes_framer_dout_ld: std_logic;
signal aes_framer_state: std_logic;
signal aes_framer_deser_ce: std_logic;
signal aes_framer_pre_detect: std_logic;
signal aes_framer_fixed_match: std_logic;
signal aes_framer_predet_in: unsigned(7 downto 0);
signal aes_framer_bitcntr: unsigned(2 downto 0);
signal aes_framer_y_detect: std_logic;
signal aes_framer_z_detect: std_logic;
signal aes_dru_update_min: std_logic;
signal aes_dru_inffs: unsigned(2 downto 0);
signal aes_dru_min_cntr: unsigned(9 downto 0);
signal aes_dru_edge_detect: std_logic;
signal aes_dru_new_min: std_logic;
signal aes_dru_sample_now: std_logic;
signal aes_dru_update_cntr: unsigned(9 downto 0);
signal aes_dru_min_hold: unsigned(9 downto 0);
signal aes_dru_min_capture: unsigned(9 downto 0);
signal aes_dru_sample_cntr: unsigned(9 downto 0);

begin



-- Input FFs
-- 
-- A shift register of three FFs is used to sample the incoming bitstream.
-- The first and second FF remove metastability from the signal. The outputs of
-- the second FF and the third FF are compared to determine when an edge occurs.
AES3_RX_DEMUXED_AES_DRU_FFS: process (clk) is
begin
    if rising_edge(clk) then
        aes_dru_inffs <= unsigned'(aes_dru_inffs(2-1 downto 0) & din);
    end if;
end process AES3_RX_DEMUXED_AES_DRU_FFS;



aes_dru_edge_detect <= (aes_dru_inffs(2) xor aes_dru_inffs(1));

-- Min Counter
-- 
-- The min counter is reset when an edge is detected and increments by 1 the rest
-- of the time, counting the number of clock cycles between edges.
AES3_RX_DEMUXED_AES_DRU_MIN_COUNTER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_dru_edge_detect) then
            aes_dru_min_cntr <= to_unsigned(0, 10);
        else
            aes_dru_min_cntr <= (aes_dru_min_cntr + 1);
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_DRU_MIN_COUNTER;

-- Minimum Capture Register
-- 
-- This register loads with a value of all ones when update_min is asserted.
-- Otherwise, when edge is asserted, it loads with the value of min counter
-- if the min count is less than the current value in the register.
AES3_RX_DEMUXED_AES_DRU_MIN_CAPTURE_REG: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_dru_edge_detect) then
            if bool(aes_dru_update_min) then
                aes_dru_min_capture <= to_unsigned(MIN_VAL_MAX, 10);
            elsif bool(aes_dru_new_min) then
                aes_dru_min_capture <= aes_dru_min_cntr;
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_DRU_MIN_CAPTURE_REG;



aes_dru_new_min <= '1' when (aes_dru_min_cntr < aes_dru_min_capture) else '0';

-- Minimum Hold Register
-- 
-- Whenever edge_detect and update_min are both asserted, this register loads
-- with the current contents of min_capture register, holding the minimum value
-- found while min_capture begins searching for a new minimum value.
AES3_RX_DEMUXED_AES_DRU_MIN_HOLD_REG: process (clk) is
begin
    if rising_edge(clk) then
        if (bool(aes_dru_edge_detect) and bool(aes_dru_update_min)) then
            aes_dru_min_hold <= aes_dru_min_capture;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_DRU_MIN_HOLD_REG;

-- Update Period Counter
-- 
-- The update period counter increments by one on every detected edge. When this
-- counter reaches its maximum count, update_min is asserted and the counter rolls
-- over to zero.
AES3_RX_DEMUXED_AES_DRU_UPDATE_PERIOD_COUNTER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_dru_edge_detect) then
            aes_dru_update_cntr <= (aes_dru_update_cntr + 1);
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_DRU_UPDATE_PERIOD_COUNTER;



aes_dru_update_min <= '1' when (aes_dru_update_cntr = update_tc) else '0';

-- Sample Counter
-- 
-- The sample counter determines when it is time to sample the bitstream output of
-- inffs[2]. This counter resets to zero when edge_detect is asserted or when the
-- sample count is equal to or greater than the min_hold value. Thus, this counter
-- counts from 0 to the min_hold value which is then length of time of one symbol
-- (half an encoded bit), then it resets and starts over. The bitstream is sampled
-- each time the sample counter reaches one half the min_hold value which is approximately
-- the middle of the symbol.
AES3_RX_DEMUXED_AES_DRU_SAMPLE_COUNTER: process (clk) is
begin
    if rising_edge(clk) then
        if (bool(aes_dru_edge_detect) or (aes_dru_sample_cntr >= aes_dru_min_hold)) then
            aes_dru_sample_cntr <= to_unsigned(0, 10);
        else
            aes_dru_sample_cntr <= (aes_dru_sample_cntr + 1);
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_DRU_SAMPLE_COUNTER;



aes_dru_sample_now <= '1' when (aes_dru_sample_cntr = unsigned'('0' & aes_dru_min_hold(MIN_VAL_WIDTH-1 downto 1))) else '0';


AES3_RX_DEMUXED_AES_DRU_OUTPUT_DATA: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_dru_sample_now) then
            recdata <= aes_dru_inffs(2);
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_DRU_OUTPUT_DATA;


AES3_RX_DEMUXED_AES_DRU_OUTPUT_VALID: process (clk) is
begin
    if rising_edge(clk) then
        recdata_valid <= aes_dru_sample_now;
    end if;
end process AES3_RX_DEMUXED_AES_DRU_OUTPUT_VALID;


AES3_RX_DEMUXED_AES_FRAMER_INPUT_SHIFT_REG: process (clk) is
begin
    if rising_edge(clk) then
        if bool(recdata_valid) then
            aes_framer_in_sr <= unsigned'(recdata & aes_framer_in_sr(9-1 downto 1));
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_FRAMER_INPUT_SHIFT_REG;



aes_framer_predet_in <= (not aes_framer_in_sr(9-1 downto 1)) when bool(aes_framer_in_sr(0)) else aes_framer_in_sr(9-1 downto 1);



aes_framer_fixed_match <= stdl(bool(aes_framer_predet_in(0)) and bool(aes_framer_predet_in(1)) and bool(aes_framer_predet_in(2)) and (not bool(aes_framer_predet_in(3))) and (not bool(aes_framer_predet_in(7))));



aes_framer_x_detect <= '1' when (bool(aes_framer_fixed_match) and (aes_framer_predet_in(7-1 downto 4) = 4)) else '0';
aes_framer_y_detect <= '1' when (bool(aes_framer_fixed_match) and (aes_framer_predet_in(7-1 downto 4) = 2)) else '0';
aes_framer_z_detect <= '1' when (bool(aes_framer_fixed_match) and (aes_framer_predet_in(7-1 downto 4) = 1)) else '0';
aes_framer_pre_detect <= '1' when (bool(aes_framer_fixed_match) and ((aes_framer_predet_in(7-1 downto 4) = 1) or (aes_framer_predet_in(7-1 downto 4) = 2) or (aes_framer_predet_in(7-1 downto 4) = 4))) else '0';


AES3_RX_DEMUXED_AES_FRAMER_DESERIALIZATION: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_framer_deser_ce) then
            aes_framer_deser <= unsigned'((aes_framer_in_sr(1) xor aes_framer_in_sr(2)) & aes_framer_deser(8-1 downto 1));
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_FRAMER_DESERIALIZATION;


AES3_RX_DEMUXED_AES_FRAMER_OUTPUT_REGISTER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_framer_dout_ld) then
            framer_out <= aes_framer_deser;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_FRAMER_OUTPUT_REGISTER;


AES3_RX_DEMUXED_AES_FRAMER_FRAMER_STATE_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            aes_framer_state <= '0';
        else
            if bool(recdata_valid) then
                if bool(aes_framer_pre_detect) then
                    aes_framer_state <= '0';
                else
                    aes_framer_state <= stdl((not bool(aes_framer_state)));
                end if;
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_FRAMER_FRAMER_STATE_LOGIC;


AES3_RX_DEMUXED_AES_FRAMER_FRAMER_CONTROL_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            aes_framer_bitcntr <= to_unsigned(0, 3);
        else
            if bool(recdata_valid) then
                if bool(aes_framer_pre_detect) then
                    aes_framer_bitcntr <= to_unsigned(0, 3);
                elsif bool(aes_framer_deser_ce) then
                    aes_framer_bitcntr <= (aes_framer_bitcntr + 1);
                end if;
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_FRAMER_FRAMER_CONTROL_LOGIC;



aes_framer_deser_ce <= stdl(bool(aes_framer_state) and bool(recdata_valid));
aes_framer_dout_ld <= '1' when ((not bool(aes_framer_state)) and bool(recdata_valid) and (aes_framer_bitcntr = 7)) else '0';


AES3_RX_DEMUXED_AES_FRAMER_DELAY_PREAMBLE_REG: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            aes_framer_int_xyz <= to_unsigned(0, 3);
        else
            if bool(recdata_valid) then
                if bool(aes_framer_pre_detect) then
                    aes_framer_int_xyz <= unsigned'(aes_framer_x_detect & aes_framer_y_detect & aes_framer_z_detect);
                elsif (aes_framer_bitcntr = 7) then
                    aes_framer_int_xyz <= to_unsigned(0, 3);
                end if;
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_FRAMER_DELAY_PREAMBLE_REG;


AES3_RX_DEMUXED_AES_FRAMER_DELAY_PREAMBLES: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            x_preamble <= '0';
            y_preamble <= '0';
            z_preamble <= '0';
        else
            if bool(aes_framer_dout_ld) then
                x_preamble <= aes_framer_int_xyz(2);
                y_preamble <= aes_framer_int_xyz(1);
                z_preamble <= aes_framer_int_xyz(0);
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_FRAMER_DELAY_PREAMBLES;


AES3_RX_DEMUXED_AES_FRAMER_DOUT_VALID_GEN: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            framer_valid <= '0';
        else
            framer_valid <= aes_framer_dout_ld;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_FRAMER_DOUT_VALID_GEN;



aes_rx_formatter_preamble_in <= stdl(bool(x_preamble) or bool(y_preamble) or bool(z_preamble));


AES3_RX_DEMUXED_AES_RX_FORMATTER_BYTE_COUNTER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(framer_valid) then
            if bool(aes_rx_formatter_preamble_in) then
                aes_rx_formatter_byte_count <= to_unsigned(1, 4);
            else
                aes_rx_formatter_byte_count <= unsigned'(aes_rx_formatter_byte_count(3-1 downto 0) & '0');
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_BYTE_COUNTER;


AES3_RX_DEMUXED_AES_RX_FORMATTER_INPUT_REGISTER: process (clk) is
    variable inreg_tmp: unsigned(27 downto 0);
begin
    if rising_edge(clk) then
        if bool(framer_valid) then
            inreg_tmp := to_unsigned(0, 28);
            inreg_tmp := aes_rx_formatter_in_reg;
            if bool(aes_rx_formatter_preamble_in) then
                inreg_tmp(4-1 downto 0) := framer_out(8-1 downto 4);
            elsif (aes_rx_formatter_byte_count(0) = '1') then
                inreg_tmp(12-1 downto 4) := framer_out;
            elsif (aes_rx_formatter_byte_count(1) = '1') then
                inreg_tmp(20-1 downto 12) := framer_out;
            elsif (aes_rx_formatter_byte_count(2) = '1') then
                inreg_tmp(28-1 downto 20) := framer_out;
            end if;
            aes_rx_formatter_in_reg <= inreg_tmp;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_INPUT_REGISTER;


AES3_RX_DEMUXED_AES_RX_FORMATTER_SUBFRAME_TRACKER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(framer_valid) then
            if bool(y_preamble) then
                aes_rx_formatter_sub <= '1';
            elsif (bool(x_preamble) or bool(z_preamble)) then
                aes_rx_formatter_sub <= '0';
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_SUBFRAME_TRACKER;


AES3_RX_DEMUXED_AES_RX_FORMATTER_FRAME_COUNTER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(framer_valid) then
            if bool(z_preamble) then
                aes_rx_formatter_frames_int <= to_unsigned(0, 8);
            elsif bool(x_preamble) then
                aes_rx_formatter_frames_int <= (aes_rx_formatter_frames_int + 1);
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_FRAME_COUNTER;



frames_int <= aes_rx_formatter_frames_int;


AES3_RX_DEMUXED_AES_RX_FORMATTER_OUTPUT_CLK: process (clk) is
begin
    if rising_edge(clk) then
        aes_rx_formatter_ce <= framer_valid;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_OUTPUT_CLK;


AES3_RX_DEMUXED_AES_RX_FORMATTER_AUDIO_OUTPUT: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_rx_formatter_ld_out) then
            audio <= aes_rx_formatter_in_reg(24-1 downto 0);
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_AUDIO_OUTPUT;


AES3_RX_DEMUXED_AES_RX_FORMATTER_CHANNEL_INDICATOR: process (clk) is
begin
    if rising_edge(clk) then
        channel1 <= stdl(bool(aes_rx_formatter_ld_out) and (not bool(aes_rx_formatter_sub)));
        channel2 <= stdl(bool(aes_rx_formatter_ld_out) and bool(aes_rx_formatter_sub));
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_CHANNEL_INDICATOR;


AES3_RX_DEMUXED_AES_RX_FORMATTER_VALID_DATA: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_rx_formatter_ld_out) then
            valid <= aes_rx_formatter_in_reg(24);
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_VALID_DATA;


AES3_RX_DEMUXED_AES_RX_FORMATTER_USER_DATA: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_rx_formatter_ld_out) then
            user_data <= aes_rx_formatter_in_reg(25);
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_USER_DATA;


AES3_RX_DEMUXED_AES_RX_FORMATTER_CHANNEL_STATUS: process (clk) is
begin
    if rising_edge(clk) then
        if bool(aes_rx_formatter_ld_out) then
            cs <= aes_rx_formatter_in_reg(26);
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_CHANNEL_STATUS;


AES3_RX_DEMUXED_AES_RX_FORMATTER_PARITY_ERROR_DETECTION: process (clk) is
    variable p: integer;
begin
    if rising_edge(clk) then
        if bool(aes_rx_formatter_ld_out) then
            p := to_integer(aes_rx_formatter_in_reg(0));
            for i in 0 to (28 - 1)-1 loop
                p := p xor to_integer(aes_rx_formatter_in_reg((i + 1)));
            end loop;
            parity_error_int <= stdl(p);
        end if;
    end if;
end process AES3_RX_DEMUXED_AES_RX_FORMATTER_PARITY_ERROR_DETECTION;



aes_rx_formatter_ld_out <= stdl(bool(aes_rx_formatter_ce) and bool(aes_rx_formatter_byte_count(3)));


AES3_RX_DEMUXED_LOCK_TIMEOUT_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if (bool(y_preamble) and bool(framer_valid)) then
            locked_timeout <= to_unsigned(0, 13);
        else
            locked_timeout <= (locked_timeout + 1);
        end if;
    end if;
end process AES3_RX_DEMUXED_LOCK_TIMEOUT_LOGIC;


AES3_RX_DEMUXED_LOCK_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if bool(rst) then
            locked <= '0';
        else
            if (bool(y_preamble) and bool(framer_valid)) then
                locked <= '1';
            elsif (locked_timeout = LCK_MAX) then
                locked <= '0';
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_LOCK_LOGIC;


AES3_RX_DEMUXED_DEMUX_REGISTERS: process (clk) is
begin
    if rising_edge(clk) then
        if bool(channel1) then
            audio1_hold <= audio;
            valid1_hold <= valid;
            user1_hold <= user_data;
            cs1_hold <= cs;
        end if;
    end if;
end process AES3_RX_DEMUXED_DEMUX_REGISTERS;


AES3_RX_DEMUXED_OUTPUT_REGS: process (clk) is
begin
    if rising_edge(clk) then
        if bool(channel2) then
            audio1 <= std_logic_vector(audio1_hold);
            valid1 <= valid1_hold;
            user1 <= user1_hold;
            cs1 <= cs1_hold;
            audio2 <= std_logic_vector(audio);
            valid2 <= valid;
            user2 <= user_data;
            cs2 <= cs;
            frames <= std_logic_vector(frames_int);
            if (frames_int = 0) then
                frame0 <= '1';
            else
                frame0 <= '0';
            end if;
        end if;
    end if;
end process AES3_RX_DEMUXED_OUTPUT_REGS;


AES3_RX_DEMUXED_OUTPUT_ENABLE_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        out_en <= channel2;
    end if;
end process AES3_RX_DEMUXED_OUTPUT_ENABLE_LOGIC;


AES3_RX_DEMUXED_PARITY_ERROR_PASS: process (clk) is
begin
    if rising_edge(clk) then
        if (bool(channel1) or bool(channel2)) then
            parity_error <= parity_error_int;
        end if;
    end if;
end process AES3_RX_DEMUXED_PARITY_ERROR_PASS;

end architecture ScryverDesign;
